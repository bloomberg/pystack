import os
import sys
from typing import Iterable
from typing import Optional

from .colors import colored
from .engine import NativeReportingMode
from .types import NativeFrame
from .types import PyCodeObject
from .types import PyFrame
from .types import PyThread
from .types import frame_type


class TracebackPrinter:
    def __init__(
        self, native_mode: NativeReportingMode, include_subinterpreters: bool = False
    ):
        self.native_mode = native_mode
        self.include_subinterpreters = include_subinterpreters
        self._current_interp_id = -1

    def print_thread(self, thread: PyThread) -> None:
        # Print interpreter header if we've switched interpreters
        if self.include_subinterpreters:
            if thread.interp_id != self._current_interp_id:
                self._print_interpreter_header(thread.interp_id)
                self._current_interp_id = thread.interp_id

        # Print the thread with indentation
        for line in format_thread(thread, self.native_mode):
            if self.include_subinterpreters:
                print(" " * 2, end="")
            print(line, file=sys.stdout, flush=True)

    def _print_interpreter_header(self, interp_id: Optional[int]) -> None:
        header = "Interpreter-"
        if interp_id is not None:
            header += str(interp_id)
        else:
            header += "Unknown"
        if interp_id == 0:
            header += " (main)"
        print(header, file=sys.stdout, flush=True)


def format_frame(frame: PyFrame) -> Iterable[str]:
    code: PyCodeObject = frame.code
    function = colored(code.scope, "yellow")
    yield (
        f'    {colored("(Python)", "green")} File "{code.filename}"'
        f", line {code.location.lineno}, in {function}"
    )
    if os.path.exists(code.filename):
        with open(code.filename, "r") as fp:
            lines = fp.readlines()
        source = lines[code.location.lineno - 1]
        line_start, line_end, col_start, col_end = code.location
        if col_start == col_end == 0:
            yield f"        {source.strip()}"
        else:
            if line_end != line_start:
                col_end = len(source)
            a = source[:col_start]
            b = source[col_start:col_end]
            c = source[col_end:]
            final = f'{a}{colored(b, color="blue")}{c}'
            yield f"        {final.strip()}"

    if frame.arguments:
        yield f"      {colored('Arguments:', attrs=['faint'])}"
        for argument, value in frame.arguments.items():
            normalized_value = repr(value)[1:-1]
            yield f"        {argument}: {normalized_value}"
    if frame.locals:
        yield f"      {colored('Locals:', attrs=['faint'])}"
        for local, value in frame.locals.items():
            normalized_value = repr(value)[1:-1]
            yield f"        {local}: {value}"


def _are_the_stacks_mergeable(thread: PyThread) -> bool:
    eval_frames = (
        frame
        for frame in thread.native_frames
        if frame_type(frame, thread.python_version) == NativeFrame.FrameType.EVAL
    )
    n_eval_frames = sum(1 for _ in eval_frames)
    n_entry_frames = sum(1 for frame in thread.all_frames if frame.is_entry)
    return n_eval_frames == n_entry_frames


def format_thread(thread: PyThread, native_mode: NativeReportingMode) -> Iterable[str]:
    native = native_mode != NativeReportingMode.OFF
    current_frame: Optional[PyFrame] = thread.first_frame
    if current_frame is None and not native:
        yield f"The frame stack for thread {thread.tid} is empty"
        return

    thread_name = f" ({thread.name}) " if thread.name else " "
    yield (
        f"Traceback for thread {thread.tid}{thread_name}{thread.status} "
        "(most recent call last):"
    )

    if not (native and _are_the_stacks_mergeable(thread)):
        if native:
            yield "* - Unable to merge native stack due to insufficient native information - *"
        while current_frame is not None:
            if not current_frame.is_shim:
                yield from format_frame(current_frame)
            current_frame = current_frame.next
    else:
        yield from _format_merged_stacks(
            thread, current_frame, native_mode == NativeReportingMode.LAST
        )
    yield ""


def _format_merged_stacks(
    thread: PyThread,
    current_frame: Optional[PyFrame],
    native_last: bool = False,
) -> Iterable[str]:
    c_frames_list: list[str] = []
    for frame in thread.native_frames:
        if frame_type(frame, thread.python_version) == NativeFrame.FrameType.EVAL:
            assert current_frame is not None
            c_frames_list = []
            yield from format_frame(current_frame)
            current_frame = current_frame.next
            while current_frame and not current_frame.is_entry:
                yield from format_frame(current_frame)
                current_frame = current_frame.next
            continue
        elif frame_type(frame, thread.python_version) == NativeFrame.FrameType.IGNORE:
            continue
        elif frame_type(frame, thread.python_version) == NativeFrame.FrameType.OTHER:
            function = colored(frame.symbol, "yellow")
            formatted_c_frame = (
                f'    {colored("(C)", "blue")} File "{frame.path}",'
                f" line {frame.linenumber},"
                f" in {function} ({colored(frame.library, attrs=['faint'])})"
            )
            if native_last:
                c_frames_list.append(formatted_c_frame)
            else:
                yield formatted_c_frame
        else:  # pragma: no cover
            raise ValueError(
                f"Invalid frame type: {frame_type(frame, thread.python_version)}"
            )
    for c_frame in c_frames_list:
        yield c_frame
